//! Implementation of the distributed key generation (DKG)
//! procedure presented by Gennaro, Jarecki, Krawczyk and Rabin in
//! ["Secure distributed key generation for discrete-log based cryptosystems."](https://link.springer.com/article/10.1007/s00145-006-0347-3).
//! The distinction with the original protocol lies in the use of hybrid
//! encryption. We use the description and notation presented in the technical
//! [spec](https://github.com/input-output-hk/treasury-crypto/blob/master/docs/voting_protocol_spec/Treasury_voting_protocol_spec.pdf),
//! written by Dmytro Kaidalov.

use crate::encryption::{HybridCiphertext, PublicKey, SecretKey};
use crate::gang::{GroupElement, Scalar};
use crate::math::Polynomial;
use crate::Crs;
use crate::errors::DkgError;
use rand_core::{CryptoRng, RngCore};

/// Committee member election secret key
#[derive(Clone)]
pub struct MemberSecretKey(pub(crate) SecretKey);

/// Committee member election public key
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct MemberPublicKey(pub(crate) PublicKey);

/// Committee member communication private key
#[derive(Clone)]
pub struct MemberCommunicationKey(SecretKey);

/// Committee Member communication public key (with other committee members)
#[derive(Clone)]
pub struct MemberCommunicationPublicKey(PublicKey);

/// The overall committee public key used for everyone to encrypt their vote to.
#[derive(Clone)]
pub struct ElectionPublicKey(pub(crate) PublicKey);

pub type DistributedKeyGeneration = MemberState1;

/// Initial state generated by a Member, corresponding to round 1.
#[derive(Clone)]
pub struct MemberState1 {
    sk: MemberSecretKey,
    threshold: usize,
    nr_members: usize,
    owner_index: usize,
    crs: Crs,
    apubs: Vec<GroupElement>,
    es: Vec<GroupElement>,
    encrypted: Vec<IndexedEncryptedShares>,
}

/// State of the member corresponding to round 2.
#[derive(Clone)]
pub struct MemberState2 {
    misbehaving_parties: Vec<MisbehavingPartiesState1>,
}

// state of members, with the index, the hybrid ctxts and the commitment to
type MembersFetchedState1 = (IndexedEncryptedShares, Vec<GroupElement>);
type IndexedEncryptedShares = (usize, HybridCiphertext, HybridCiphertext);
// todo: third element should be a proof of misbehaviour.
type MisbehavingPartiesState1 = (usize, DkgError, usize);

impl MemberState1 {
    /// Generate a new member state from random. This is round 1 of the protocol. Receives as
    /// input the threshold `t`, the expected number of participants, `n`, common reference string
    /// `crs`, `committee_pks`, and the party's index `my`. Initiates a Pedersen-VSS as a dealer.
    pub fn init<R: RngCore + CryptoRng>(
        rng: &mut R,
        t: usize,
        n: usize,
        crs: &Crs, // TODO: document
        committee_pks: &[MemberCommunicationPublicKey],
        my: usize,
    ) -> MemberState1 {
        assert_eq!(committee_pks.len(), n);
        assert!(t > 0);
        assert!(t <= n);
        assert!(t > n / 2);
        assert!(my < n);

        let pcomm = Polynomial::random(rng, t);
        let pshek = Polynomial::random(rng, t);

        let mut coeff_comm = Vec::with_capacity(t);
        let mut es = Vec::with_capacity(t);

        for (ai, bi) in pshek.get_coefficients().zip(pcomm.get_coefficients()) {
            let apub = GroupElement::generator() * ai;
            let e = &apub + crs * bi;
            coeff_comm.push(apub);
            es.push(e);
        }

        let mut encrypted_shares: Vec<IndexedEncryptedShares> = Vec::with_capacity(n - 1);
        #[allow(clippy::needless_range_loop)]
        for i in 0..n {
            // don't generate share for self
            if i == my {
                continue;
            } else {
                let idx = Scalar::from_u64((i + 1) as u64);
                let share_comm = pcomm.evaluate(&idx);
                let share_shek = pshek.evaluate(&idx);

                let pk = &committee_pks[i];

                let ecomm = pk.0.hybrid_encrypt(&share_comm.to_bytes(), rng);
                let eshek = pk.0.hybrid_encrypt(&share_shek.to_bytes(), rng);

                encrypted_shares.push((i, ecomm, eshek));
            }
        }

        MemberState1 {
            sk: MemberSecretKey(SecretKey {
                sk: pshek.at_zero(),
            }),
            crs: crs.clone(),
            threshold: t,
            nr_members: n,
            owner_index: my + 1, // committee member are 1-indexed
            apubs: coeff_comm,
            es,
            encrypted: encrypted_shares,
        }
    }

    // todo: is vectors a correct way to handle the indexed members (e.g.: coeff_comms and pks in
    // a vec will certainly enduce errors)?
    pub fn to_phase_2(
        &self,
        secret_key: &MemberCommunicationKey,
        members_state: &Vec<MembersFetchedState1>,
    ) -> Result<MemberState2, DkgError> {
        let mut misbehaving_parties: Vec<MisbehavingPartiesState1> = Vec::new();
        for fetched_data in members_state {
            let comm_scalar = Scalar::from_bytes(
                &secret_key.0.hybrid_decrypt(&fetched_data.0.1));
            let shek_scalar = Scalar::from_bytes(
                &secret_key.0.hybrid_decrypt(&fetched_data.0.2));

            if let (Some(comm), Some(shek)) = (comm_scalar, shek_scalar) {
                let index_pow = Scalar::from_u64(self.owner_index as u64)
                    .exp_iter()
                    .take(self.threshold + 1);

                let check_element = GroupElement::generator() * shek + &self.crs * comm;
                #[cfg(feature = "ristretto255")]
                let multi_scalar = GroupElement::vartime_multiscalar_multiplication(index_pow, fetched_data.1.clone());
                #[cfg(not(feature = "ristretto255"))]
                let multi_scalar = GroupElement::multiscalar_multiplication(index_pow, fetched_data.1.clone());

                if check_element != multi_scalar {
                    misbehaving_parties.push((fetched_data.0.0.clone(), DkgError::ShareValidityFailed, 0));
                }
            }
            else {
                // todo: handle the proofs. Might not be the most optimal way of handling these two
                misbehaving_parties.push((fetched_data.0.0.clone(), DkgError::ScalarOutOfBounds, 0));
            }
        }

        if misbehaving_parties.len() == self.threshold {
            return Err(DkgError::MisbehaviourHigherThreshold);
        }

        Ok(MemberState2{misbehaving_parties})

    }

    pub fn secret_key(&self) -> &MemberSecretKey {
        &self.sk
    }

    pub fn public_key(&self) -> MemberPublicKey {
        MemberPublicKey(PublicKey {
            pk: self.apubs[0].clone(),
        })
    }
}

impl MemberSecretKey {
    pub fn to_bytes(&self) -> [u8; 32] {
        self.0.sk.to_bytes()
    }

    pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let sk = Scalar::from_bytes(bytes)?;
        Some(Self(SecretKey { sk }))
    }
}

impl MemberPublicKey {
    pub const BYTES_LEN: usize = PublicKey::BYTES_LEN;

    pub fn to_bytes(&self) -> Vec<u8> {
        self.0.to_bytes()
    }

    pub fn from_bytes(buf: &[u8]) -> Option<Self> {
        Some(Self(PublicKey::from_bytes(buf)?))
    }
}

impl From<PublicKey> for MemberPublicKey {
    fn from(pk: PublicKey) -> MemberPublicKey {
        MemberPublicKey(pk)
    }
}

impl MemberCommunicationKey {
    pub fn new<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        let sk = SecretKey::generate(rng);
        MemberCommunicationKey(sk)
    }

    pub fn to_public(&self) -> MemberCommunicationPublicKey {
        MemberCommunicationPublicKey(PublicKey {
            pk: &GroupElement::generator() * &self.0.sk,
        })
    }

    pub fn from_bytes(bytes: &[u8]) -> Option<MemberCommunicationKey> {
        SecretKey::from_bytes(bytes).map(MemberCommunicationKey)
    }

    pub fn to_bytes(&self) -> [u8; 32] {
        self.0.sk.to_bytes()
    }
}

impl MemberCommunicationPublicKey {
    pub fn from_public_key(pk: PublicKey) -> Self {
        Self(pk)
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        self.0.to_bytes()
    }

    pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
        PublicKey::from_bytes(bytes).map(Self)
    }
}

impl ElectionPublicKey {
    /// Create an election public key from all the participants of this committee
    pub fn from_participants(pks: &[MemberPublicKey]) -> Self {
        let mut k = pks[0].0.pk.clone();
        for pk in &pks[1..] {
            k = k + &pk.0.pk;
        }
        ElectionPublicKey(PublicKey { pk: k })
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        self.0.to_bytes()
    }

    pub fn from_bytes(buf: &[u8]) -> Option<Self> {
        PublicKey::from_bytes(buf).map(ElectionPublicKey)
    }

    #[doc(hidden)]
    pub fn as_raw(&self) -> &PublicKey {
        &self.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand_chacha::ChaCha20Rng;
    use rand_core::SeedableRng;

    #[test]
    fn valid_phase_2() {
        let mut rng = ChaCha20Rng::from_seed([0u8; 32]);

        let mut shared_string =
            b"Example of a shared string. This should be VotePlan.to_id()".to_owned();
        let h = Crs::from_hash(&mut shared_string);

        let mc1 = MemberCommunicationKey::new(&mut rng);
        let mc2 = MemberCommunicationKey::new(&mut rng);
        let mc = [mc1.to_public(), mc2.to_public()];

        let threshold = 2;
        let nr_members = 2;

        let m1 = DistributedKeyGeneration::init(&mut rng, threshold, nr_members, &h, &mc, 0);
        let m2 = DistributedKeyGeneration::init(&mut rng, threshold, nr_members, &h, &mc, 1);

        // Now, party one fetches the state of the other parties, mainly party two and three
        let fetched_state = vec![(m2.encrypted[0].clone(), m2.es.clone())];

        let phase_2 = m1.to_phase_2(&mc1, &fetched_state);

        assert!(phase_2.is_ok());
    }
    #[test]
    fn invalid_phase_2() {
        let mut rng = ChaCha20Rng::from_seed([0u8; 32]);

        let mut shared_string =
            b"Example of a shared string. This should be VotePlan.to_id()".to_owned();
        let h = Crs::from_hash(&mut shared_string);

        let mc1 = MemberCommunicationKey::new(&mut rng);
        let mc2 = MemberCommunicationKey::new(&mut rng);
        let mc3 = MemberCommunicationKey::new(&mut rng);
        let mc = [mc1.to_public(), mc2.to_public(), mc3.to_public()];

        let threshold = 2;
        let nr_members = 3;

        let m1 = DistributedKeyGeneration::init(&mut rng, threshold, nr_members, &h, &mc, 0);
        let m2 = DistributedKeyGeneration::init(&mut rng, threshold, nr_members, &h, &mc, 1);
        let m3 = DistributedKeyGeneration::init(&mut rng, threshold, nr_members, &h, &mc, 2);

        // Now, party one fetches invalid state of the other parties, mainly party two and three
        let fetched_state = vec![
            (m2.encrypted[0].clone(), vec![GroupElement::zero(); 3]),
            (m3.encrypted[0].clone(), vec![GroupElement::zero(); 3])];

        let phase_2_faked = m1.to_phase_2(&mc1, &fetched_state);
        // todo: we probably want to check for a particular error here
        assert!(phase_2_faked.is_err());
    }
}
